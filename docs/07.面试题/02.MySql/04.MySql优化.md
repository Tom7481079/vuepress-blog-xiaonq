---
title: MySql优化
date: 2021-02-09 11:43:24
permalink: /pages/911341/
categories:
  - 面试题
  - MySql
tags:
  - 
---
# 01.MySQL索引优化

```python
# 1、最左前缀匹配原则，上面讲到了
# 2、主键外键一定要建索引
# 3、对 where,on,group by,order by 中出现的列使用索引
# 4、尽量选择区分度高的列作为索引,区分度的公式是count(distinct col)/count(*)，表示字段不重复的比例，
# 5、为较长的字符串使用前缀索引

'''
# 6、不要过多创建索引, 权衡索引个数与DML之间关系，DML也就是插入、删除数据操作。
    这里需要权衡一个问题，建立索引的目的是为了提高查询效率的，但建立的索引过多，
    会影响插入、删除数据的速度，因为我们修改的表数据，索引也需要进行调整重建
'''

'''
# 7、对于like查询，”%”不要放在前面。
    SELECT * FROMhoudunwangWHEREunameLIKE'后盾%' -- 走索引 
    SELECT * FROMhoudunwangWHEREunameLIKE "%后盾%" -- 不走索引
'''

'''
# 8、查询where条件数据类型不匹配也无法使用索引 
    字符串与数字比较不使用索引; 
    CREATE TABLEa(achar(10)); 
    EXPLAIN SELECT * FROMaWHEREa="1" – 走索引 
    EXPLAIN SELECT * FROM a WHERE a=1 – 不走索引 
    正则表达式不使用索引,这应该很好理解,所以为什么在SQL中很难看到regexp关键字的原因
'''
```

# 02.MySql分库分表

`了解内容，不作为学习重点`

- mysql一主多从，读写分离：写主库，读从库（所有数据库的数据一样）
  - 数据一样的，那么当数据量太大的时候查询还是很慢
- 分库（根据用户id分库）
  - 所有数据库的表结构一样，存储的数据完全不一样
  - 真实环境以用户id进行分库，每一个库的数据都很小，查询起来就快了
  - 无法解决问题：当一个数据库中表中量过大的时候，查询依然会慢
- 分表（根据时间分表）
  - 当一个表中数据过大的时候，我们必须要对表拆分
  - 购物清单表中有两千万数据
    - 最近半年的购物数据时 一百万
    - 半年到一年的数据有五百万
    - 一年以前的数据有一千万

# 03.MySQL慢查询

## 3.1 什么是mysql慢查询

- MySQL的慢查询，全名是**慢查询日志**，是MySQL提供的一种日志记录，用来记录在MySQL中**响应时间超过阀值**的语句。
- 运行时间超过`long_query_time`值的SQL语句，则会被记录到慢查询日志中。
- `long_query_time`的默认值为`10`，意思是记录运行`10`秒以上的语句。

## 3.2 查找那些语句慢

```javascript
# 比如，得到返回记录集最多的10个SQL。
mysqldumpslow -s r -t 10 /database/mysql/mysql06_slow.log

# 得到访问次数最多的10个SQL
mysqldumpslow -s c -t 10 /database/mysql/mysql06_slow.log

# 得到按照时间排序的前10条里面含有左连接的查询语句。
mysqldumpslow -s t -t 10 -g “left join” /database/mysql/mysql06_slow.log

# 另外建议在使用这些命令时结合 | 和more 使用 ，否则有可能出现刷屏的情况。
mysqldumpslow -s r -t 20 /mysqldata/mysql/mysql06-slow.log | more
```

## 3.3 explain分析慢查询原因

- 使用 EXPLAIN 关键字可以让你知道MySQL是如何处理你的SQL语句的。这可以帮你分析你的查询语句或是表结构的性能瓶颈。
- EXPLAIN 的查询结果还会告诉你你的索引主键被如何利用的，你的数据表是如何被搜索和排序的……等等，等等。

- explain的执行效果

```javascript
mysql> explain select * from subject where id = 1 \G
******************************************************
           id: 1
  select_type: SIMPLE
        table: user             # 表示访问那个表
   partitions: NULL
         type: const
possible_keys: PRIMARY
          key: PRIMARY           # 使用了主键索引，如果为null代表没有使用索引
      key_len: 4                # 表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度
          ref: const
         rows: 1
     filtered: 100.00             # 查询的表行占表的百分比
        Extra: NULL
******************************************************
```



