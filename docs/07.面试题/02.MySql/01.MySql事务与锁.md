---
title: MySql事务与锁
date: 2021-02-09 11:43:24
permalink: /pages/172127/
categories:
  - 面试题
  - MySql
tags:
  - 
---
# 01.mysql事务

## 1.1 InnoDB事务原理

- 事务（Transaction）是数据库区别于文件系统的重要特性之一，事务会把数据库从一种一致性状态转换为另一种一致性状态。
- 在数据库提交时，可以确保要么所有修改都已保存，要么所有修改都不保存。


## 1.2 事务四大特性

- 原子性：整个事物的所有操作要么全部提交成功，要么全部失败回滚(`要么全部执行，要么全部回滚`)。
- 一致性：几个并行执行的事务，其执行结果必须与按某一顺序串行执行的结果相一致（`几个并行事务执行结果相同`）。
- 隔离性：事务的执行不受其他事务的干扰，事务执行的中间结果对其他事务必须是透明的。
- 持久性:  一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。

> `原子性和一致性区别`

- 原子性并不能保证一致性，在多事务并行情况下，即使保证每个事物原子性，仍然可能数据不一致
- 比如：假如同时开启两个事物A和B都要给tom账号转100元，可能增加两次，但是有一次被另一个事物覆盖

## 1.3 InnoDB与MyISAM

- **`MyISAM不支持事物回滚，InnoDB是支持事物`**
- **MyISAM**和MEMORY存储引擎采用的是**表级锁**（table-level locking）。
- **InnoDB**存储引擎既支持**行级锁**（row-level locking），也支持**表级锁**，但默认情况下是采用行级锁。
  - MyISAM更适合查询多的情况
  - InnoDB更适合写入多的

## 1.4 事务隔离级别

### 1.4.1 未提交读: 脏读

- `读取到其他事务修改但未提交数据`

- 1）事务2查询到的数据是事务1中修改但未提交的数据，但因为事务1回滚了数据
- 2）所以事务2查询的数据是不正确的，因此出现了脏读的问题。

### 1.4.2 提交读: 不可重复读

- `事务1读取到事务2修改前和修改后的数据，两次读取数据不一样`

- **注：**一个事务从开始到提交之前对数据所做的改变对其它事务是不可见的，这样就解决在READ-UNCOMMITTED级别下的脏读问题。
- 1）事务2执行update语句但未提交前，事务1的前两个select操作返回结果是相同的。
- 2）但事务2执行commit操作后，事务1的第三个select操作就读取到事务2对数据的改变。
- 3）导致与前两次select操作返回不同的数据，因此出现了不可重复读的问题。

### 1.4.3 可重复读: 幻读(mysql默认)

- `事务1在自己版本号中，查询到另一个事务插入新的数据行，这就会导致该事物中凭空多出数据行`

- `这是MySQL的默认事务隔离级别`

- 1）事务每开启一个实例，都会分配一个版本号给它，如果读取的数据行正在被其它事务执行DELETE或UPDATE操作（即该行上有排他锁）

- 2）这时该事物的读取操作不会等待行上的锁释放，而是根据版本号去读取行的快照数据（记录在undo log中）

- 3）这样，事务中的查询操作返回的都是同一版本下的数据，解决了不可重复读问题。

- 4）虽然该隔离级别下解决了不可重复读问题，但理论上会导致另一个问题：幻读（Phantom Read）。

- 5）一个事务在执行过程中，另一个事物对已有数据行的更改，MVCC机制可保障该事物读取到的原有数据行的内容相同

- 6）但并不能阻止另一个事务插入新的数据行，这就会导致该事物中凭空多出数据行，像出现了幻读一样，这便是幻读问题。

### 1.4.4 可串行读

- 1）这是事务的最高隔离级别，通过强制事务排序，使之不可能相互冲突，就是在每个读的数据行加上共享锁来实现。

- 2）在该隔离级别下，可以解决前面出现的脏读、不可重复读和幻读问题，但也会导致大量的超时和锁竞争现象，一般不推荐使用。



# 02.mysql中的锁

## 2.1 锁分类

- `按使用方式划分`：乐观锁、悲观锁
- `按锁级别划分`：共享锁、排他锁
- `按锁的粒度划分`：表级锁、行级锁、页级锁
- 按操作划分：DML锁，DDL锁

- 按加锁方式划分：自动锁、显示锁

## 2.2 共享锁和排它锁 

- 共享锁（`读锁`）
  -  共享锁又叫读锁，如果事务T对A加上共享锁，则其它事务只能对A再加共享锁，不能加其它锁。
  -  获准共享锁的事务只能读数据，不能写数据。
  -  用法： SELECT … LOCK IN SHARE MODE;

- 排它锁（`写锁`）
  - 排它锁又叫写锁，如果事务T对A加上排它锁，则其它事务都不能对A加任何类型的锁。获准排它锁的事务既能读数据，又能写数据。
  - 用法 ：  SELECT … FOR UPDATE


## 2.3 乐观锁和悲观锁

### 2.3.1 悲观锁：写少读多

- MySQL会对查询结果集中`每行数据都添加排他锁`，`其他线程对该记录的更新与删除操作都会阻塞`

- 申请前提：`没有线程对该结果集中的任何行数据使用排他锁或共享锁，否则申请会阻塞`。

- 适用场景：悲观锁适合写入频繁的场景。

> `对商品数量-1操作，悲观锁实现`
>
> -  每次获取商品时，对该商品加排他锁
> - 也就是在用户A获取获取 id=1 的商品信息时对该行记录加锁，期间其他用户阻塞等待访问该记录。

```python
#### 悲观锁实现加一操作代码
# 我们可以看到，首先通过begin开启一个事物，在获得shop信息和修改数据的整个过程中都对数据加锁，保证了数据的一致性。
'''
begin;
select id,name,stock as old_stock from shop  where id=1 for update;
update shop set stock=stock-1 where id=1 and stock=old_stock;
commit
'''
```

### 2.3.2 乐观锁：读多写少

- 在更新数据的时候需要比较程序中的库存量与数据库中的库存量是否相等，如果相等则进行更新。

- 反之`程序重新获取库存量，再次进行比较，直到两个库存量的数值相等才进行数据更新`。

> `乐观锁实现对商品-1操作`
>
> - 每次获取商品时，不对该商品加锁。
> - 在更新数据的时候需要比较程序中的库存量与数据库中的库存量是否相等，如果相等则进行更新
> - 反之程序重新获取库存量，再次进行比较，直到两个库存量的数值相等才进行数据更新。

```python
#### 乐观锁实现加一操作代码
# 我们可以看到，只有当对数量-1操作时才会加锁，只有当程序中值和数据库中的值相等时才正真执行。
'''
//不加锁
select id,name,stock where id=1;
//业务处理
begin;
update shop set stock=stock-1 where id=1 and stock=stock;
commit;
'''
```

## 2.4 行级锁 & 表级锁

- 行级锁（写多读少）开销大，加锁慢，锁定粒度最小，**发生锁冲突概率最低**，并发度最高
- 表级锁（适合大量的读操作）开销小，加锁快，锁定粒度大、发生锁冲突最高，并发度最低

