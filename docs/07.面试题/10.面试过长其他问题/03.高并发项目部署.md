---
title: 高并发项目部署
date: 2021-02-09 11:43:24
permalink: /pages/904d39/
categories:
  - 面试题
  - 面试过长其他问题
tags:
  - 
---
# 公司环境介绍

- 开发环境
    - 本地电脑
    - 开发机器：
        - 给开发人员自己用的测试机器
        - 比较大的公司才会有（公司给每一个开发人员可能都会配置一个单独的机器作为开发机器，这个机器是线上的）
- 测试环境
    - 代码开发完毕后，把dev分支上新的代码部署到测试环境
    - 有专业的测试人员进行测试
- 沙箱环境/灰度环境
    - 代码全量上线前，在某一台机器中部署新的代码，观察上线后监控反馈的结果
    - 如果没有问题，在所有线上机器全量同步
    - 如果有报警，证明代码有问题，自动回到某一个稳定版本
- 线上环境
    - 在线上机群众部署的项目，直接给用户用的



# 01.测试环境部署

- 测试环境使用docker-compose+docker直接快速部署
- redis和mysql等这些数据库我们应该怎么处理
    - 第一种方法：可以在django项目settings.py中配置数据库地址为测试环境数据库地址，docker只用来部署我们项目代码
    - 第二种方法（如下图）：可以直接在docker-compose的 yml文件中配置临时启动一个数据库

<img src="assets/image-20200519092222466.png" style="width: 1200px; margin-left: 50px;"> </img>



# 02.线上真实环境部署(方法1：传统部署)

- 阿里云SLB做负载均衡，类似于keepalive，把流量分发给两个nginx反向代理

- nginx反向代理中配置upstream，代理给真实server集群

- 每台真实server机器部署项目代码(django+uwsgi+nginx)

- 后面的mysql机器、redis集群等都是在真实的多台机器上部署的

    - 比如一个一主三从的机器（至少三台机器）
        -  需要四台真实的阿里云机器来部署
        - 一台机器部署mysql的master，然后在另外三天真实机器上部署mysql的slave
    - 同理如果是部署redis哨兵模式（至少三台机器）
        - 一个真实机器部署master
        - 两个机器部署slave

- 代码变更上线怎么做？

    - 使用ansible同时到部署真实代码的所有机器中，拉取gitlab中最新分支的代码部署到对应机器上，重启服务即可
    - 注意：线上服务更新不需要开发人员参与的，一般由运维人员部署，开发没权限管理这些机器
    - 或者说你们只用申请一个工单，所有流程都自动化了，只要运维审批自动上线，出现异常会自动的回滚
    - 工单系统怎么做？
        - 工单系统只调用了，代码发布平台，代码自动发布到线上
    - 自动化让代码上线怎么做？（这一块是代码发布平台的功能CI/CD和工单系统没什么关系）
        - 特别简单，ansible可以拉取线上指定分支的代码
        - 获取到代码后用ansible把代码复制到多台机器上
        - 其实代码上线完成上面两步就可以了，但是要警惕，如果线上代码出现异常，需要回滚

    

![image-20200519092104625](assets/image-20200519092104625.png)



# 03.线上真实环境部署(方法2：结合K8S部署)

## 3.1 使用docker-compose怎么部署

- 第一写一个 docker-compose.yml文件,yml文件中定义了，要运行哪些docker容器
- 第二步：docker-compose up -d  就可以启动

```python
version: '3'                       # cocker compose版本号

services:                          # 顶级配置文件
  mysql:                           # 服务名: 容器建通信、管理容器
    image: mysql:5.7               # 引入官方mysql镜像
    volumes:
      - ./mysql:/var/lib/mysql         # 把当前文件夹下的 ./mysql文件夹挂载到docker容器 /var/lib/mysql 路径下
    expose:
      - "3306"                        # 将当前容器的端口3306端口暴露给link到本容器的容器
    restart: always                   # 宿主机重启自动拉起这个docker容器
    environment:
      - MYSQL_ROOT_PASSWORD=root             # mysql服务器root密码root
      - MYSQL_DATABASE=djangodocker          # 创建数据库 djangodocker
      - MYSQL_USER=django                    # 创建一个用户 django
      - MYSQL_PASSWORD=django                # 用户密码为django

  nginx:
    image: nginx:alpine
    volumes:
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf
      - ./nginx/conf:/etc/nginx/conf.d
      - ./web/staticfiles:/django_static
    ports:
      - "80:80"                             # 绑定容器的80端口到主机的80端口
    depends_on:
      - web                                 # 必须先启动web容器然才能启动nginx容器

  redis:
    image: redis:alpine
    expose:
      - "6379"
    restart: always

  web:
    build: .
    # command: python manage.py runserver 0:8000
    # ports:
    #   - "8000:8000"
    command: uwsgi --ini uwsgi.ini             # 启动uwsgi命令
    working_dir: /code/web                     # 项目工作路径
    volumes:
      - .:/code                                # 将当前文件夹下所有文件挂载到容器的 /code 文件夹
    expose:
      - "8000"
    depends_on:                                # 必须mysql和reids容器启动后才能启动web容器
      - mysql
      - redis

  celery:
    build: .
    command: celery -A web worker -l info
    working_dir: /code/web
    volumes:
      - .:/code
    depends_on:
      - mysql
      - redis
```

## 3.2 使用k8s如何部署

- 通过声明式语法定义Pods,类似于上面的docker-compose.yml文件
- 在这里面定义要启动那些pod(docker容器)，每个pod状态

```python
### vim db.yml
### kubectl explain pod  # 查看下面参数意义
apiVersion: v1  # 描述版本 (查看版本号命令：kubectl api-versions)
kind: Pod  # 资源类型
metadata:  # 原数据
  name: db  # pod名称
  labels:  # 便签名称
    type: db  # 值是db
    vendor: MongoLabs  # 标签
spec: # 描述容器信息
  containers:  # 指容器
  - name: db  # 指定pod里的一个db容器
    image: mongo:3.3  # 镜像名称
    command: ["mongod"]  # 执行的命令
    args: ["--rest", "--httpinterface"]  # 执行启动命令的参数
```

- 执行 `kubectl create -f db.yml`就可以在k8s集群中启动这个服务

```
'''1. 使用申明式语法创建pod并查看pod详细信息 '''
[root@linux-node1 ~]# vi db.yml  # 新建定义pod文件
[root@linux-node1 ~]# kubectl create -f db.yml  # 使用db.yml创建pod
[root@linux-node1 ~]# kubectl get pods  # 查看创建的pod信息
[root@linux-node1 ~]# kubectl get pods -o wide  # 显示pod详细信息
[root@linux-node1 ~]# kubectl get pods -o json  # 以json格式显示pod信息
[root@linux-node1 ~]# kubectl describe pod db  # 查看 pod名称为db的描述信息
[root@linux-node1 ~]# kubectl delete pod db   # 使用yml安装的pod可以直接使用此命令删除
```

- 项目中常见的mysql集群/redis集群等不需要部署到k8s集群中
    - 后面的mysql机器、redis集群等都是在真实的多台机器上部署的
        - 比如一个一主三从的机器（至少三台机器）
            -  需要四台真实的阿里云机器来部署
            - 一台机器部署mysql的master，然后在另外三天真实机器上部署mysql的slave
        - 同理如果是部署redis哨兵模式（至少三台机器）
            - 一个真实机器部署master
            - 两个机器部署slave



## 3.3.k8s作用（快速迭代、服务自愈）

- 快速迭代

    - 可以使用docker快速的部署项目，回滚等

- 服务自愈

    - 在etcd存储了我们这个k8s集群要运行哪些服务，服务状态是什么样的这个描述

    - k8s会定期检查etcd中要运行的服务是否正常，如果不正常，k8s会自动的治愈

        - 在节点故障时重新启动失败的容器，替换和重新部署，保证预期我们设置的副本的数量；
- 杀死健康检测失败的容器，并且在没有准备好之前是不会处理客户端请求的（不对外提供服务），保证线上服务不中断





## 3.4 k8s最常见应用场景：微服务

- 京东商城
    - 商品展示模板
    - 商品查询模块
    - 支付模块
    - 订单模块
    - ....
- 我们传统的服务是把这个项目完整的部署到一块，每一个服务都可以提供所有接口查询

<img src="assets/image-20200522150506335.png" style="width: 1200px; margin-left: 50px;"> </img>























